# 1. Реализовать скрипт, в котором должна быть предусмотрена функция расчёта заработной платы сотрудника.
# Используйте в нём формулу: (выработка в часах*ставка в час) + премия.
# Во время выполнения расчёта для конкретных значений необходимо запускать скрипт с параметрами.
from sys import argv
from functools import reduce
from itertools import cycle, count


def task_1_argv(hours: int = 0, salary: float = 0.0, bonus: float = 0.0):
    lv_sum = (hours * salary) + bonus
    print(f"\nIncome: {lv_sum}")


# 2. Представлен список чисел. Необходимо вывести элементы исходного списка, значения которых больше предыдущего элемента.
# Подсказка: элементы, удовлетворяющие условию, оформить в виде списка. Для его формирования используйте компрехенсив.
# Пример исходного списка: [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55].
# Результат: [12, 44, 4, 10, 78, 123].
def task_2():
    lv_list = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55]
    try:
        lv_list_2 = [el for num, el in enumerate(lv_list) if num > 1 if el > lv_list[num - 1]]
    except:
        print("except oops")

    print(lv_list, lv_list_2, sep="\n")


# 3. Для чисел в пределах от 20 до 240 найти числа, кратные 20 или 21. Решите задание в одну строку.
# Подсказка: используйте функцию range() и компрехенсив.
def task_3():
    lv_list = [el for el in range(20, 241) if el % 20 == 0 or el % 21 == 0]
    print(lv_list)


# 4. Представлен список чисел. Определите элементы списка, не имеющие повторений.
# Сформируйте итоговый массив чисел, соответствующих требованию.
# Элементы выведите в порядке их следования в исходном списке.
# Для выполнения задания обязательно используйте компрехенсив.

# Пример исходного списка: [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11].
# Результат: [23, 1, 3, 10, 4, 11]
def task_4():
    lv_list = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
    lv_list_result = [el for el in lv_list if lv_list.count(el) == 1]

    print(lv_list_result)


# 5. Реализовать формирование списка, используя функцию range() и возможности компрехенсив.
# В список должны войти чётные числа от 100 до 1000 (включая границы).
# Нужно получить результат вычисления произведения всех элементов списка.

# Подсказка: использовать функцию reduce().
def task_5():
    lv_list = [el for el in range(100, 1001) if el % 2 == 0]
    print(lv_list)

    lv_result = reduce(lambda x, y: x * y, lv_list)

    print(f"result:{lv_result} \nlength of result: {len(str(lv_result))}",
          sep="\n")  # рейндж 6ю нулями уже прям устал ждать пока посчитает. Не дождался


# 6. Реализовать два небольших скрипта:

# итератор, генерирующий целые числа, начиная с указанного;
# итератор, повторяющий элементы некоторого списка, определённого заранее.
# Подсказка: используйте функцию count() и cycle() модуля itertools.
# Обратите внимание, что создаваемый цикл не должен быть бесконечным.
# Предусмотрите условие его завершения.
# Например, в первом задании выводим целые числа, начиная с 3. При достижении числа 10 — завершаем цикл.
# Вторым пунктом необходимо предусмотреть условие, при котором повторение элементов списка прекратится.
def task_6():
    # count
    for temp in count(4):
        if (temp > 29):
            print("Finish")
            break
        print(temp)
    # cycle. Плод фантазии.
    lv_list_cycle = list("Test string, just 9 times.")
    lv_end = 0
    for el in cycle(lv_list_cycle):
        if (el == "9"):
            lv_end += 1
            if (lv_end == 9):
                print("\nFinish.")
                break
        if (el == '.'):
            print("\n")
        print(el, end="")


# 7. Реализовать компрехенсив с помощью функции с ключевым словом yield, создающим очередное значение.
# При вызове функции должен создаваться объект-компрехенсив.
# Функция вызывается следующим образом: for el in fact(n).
# Она отвечает за получение факториала числа.
# В цикле нужно выводить только первые n чисел, начиная с 1! и до n!.

# Подсказка: факториал числа n — произведение чисел от 1 до n. Например, факториал четырёх 4! = 1 * 2 * 3 * 4 = 24.
def task_7(n: int=1) -> int:

    for el in range(1, n+1):
        lv_i = 1
        for el_2 in range (1,el+1):
            lv_i *= el_2
        yield lv_i


if __name__ == '__main__':
    # Первое задание только через аргументы. Считаем, что если аргументы ввели, значит первое задание.
    if (len(argv) > 2):
        # print("\nArguments", argv)
        try:
            sname, hours, salary, bonus = argv
            task_1_argv(
                hours=int(hours),
                salary=float(salary),
                bonus=float(bonus)
            )
        except ValueError as err:
            print("Use parameters - hours, salary, bonus")

    # выбор задания 2-7
    while not (lv_task := int(input("\nChoose the task (2-7): "))) in range(2, 8): pass
    if (lv_task == 2):
        task_2()
    if (lv_task == 3):
        task_3()
    if (lv_task == 4):
        task_4()
    if (lv_task == 5):
        task_5()
    if (lv_task == 6):
        task_6()
    if (lv_task == 7):
        for n in task_7(8):
            print(f"\n{n}")